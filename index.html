<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CITY OF ASH | LONDON SURVIVAL</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root { --accent: #d32f2f; --font: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; font-family: var(--font); color: white; user-select: none; }
        canvas { display: block; }

        /* REGION: UI (MENUS + HUD) */
        #ui-layer { position: absolute; inset: 0; pointer-events: none; z-index: 10; }
        .menu-overlay { position: absolute; inset: 0; background: rgba(0,0,0,0.85); display: flex; flex-direction: column; align-items: center; justify-content: center; pointer-events: all; transition: opacity 0.5s; }
        .hidden { display: none !important; opacity: 0; }
        
        h1 { font-size: 5rem; letter-spacing: 12px; margin-bottom: 2rem; text-transform: uppercase; color: var(--accent); text-shadow: 0 0 20px rgba(211, 47, 47, 0.6); }
        .btn { background: transparent; border: 1px solid white; color: white; padding: 1.2rem 3.5rem; font-size: 1.3rem; cursor: pointer; transition: 0.3s; margin: 0.6rem; width: 320px; text-transform: uppercase; font-weight: bold; }
        .btn:hover { background: white; color: black; box-shadow: 0 0 25px white; }
        
        #hud { position: absolute; inset: 0; pointer-events: none; padding: 2rem; display: flex; flex-direction: column; justify-content: space-between; }
        .hud-top { display: flex; justify-content: space-between; align-items: flex-start; }
        #minimap-container { width: 200px; height: 200px; background: rgba(0,0,0,0.7); border: 2px solid #555; position: relative; overflow: hidden; }
        #minimap-canvas { width: 100%; height: 100%; }

        .hud-bottom { display: flex; justify-content: space-between; align-items: flex-end; }
        .stats-group { background: rgba(0,0,0,0.6); padding: 15px; border-left: 4px solid var(--accent); }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 24px; height: 24px; border: 2px solid rgba(255,255,255,0.7); border-radius: 50%; transform: translate(-50%, -50%); }
        #crosshair::after { content: ''; position: absolute; top: 50%; left: 50%; width: 4px; height: 4px; background: red; border-radius: 50%; transform: translate(-50%, -50%); }

        .bar-container { width: 250px; height: 12px; background: #222; margin-top: 8px; border: 1px solid #444; }
        #health-fill { height: 100%; width: 100%; background: var(--accent); transition: width 0.2s; }
        #interact-prompt { position: absolute; bottom: 30%; left: 50%; transform: translateX(-50%); font-size: 1.5rem; color: #ffeb3b; text-shadow: 2px 2px 4px black; font-weight: bold; }
        #damage-flash { position: absolute; inset: 0; background: radial-gradient(circle, transparent 30%, rgba(211, 47, 47, 0.5) 100%); opacity: 0; pointer-events: none; transition: opacity 0.1s; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="damage-flash"></div>

        <div id="main-menu" class="menu-overlay">
            <h1>CITY OF ASH</h1>
            <button class="btn" onclick="game.start()">ENTER THE CITY</button>
            <button class="btn" onclick="alert('WASD: Move\nSHIFT: Sprint\nSPACE: Jump\nE: Interact\nLEFT CLICK: Shoot')">HOW TO PLAY</button>
        </div>

        <div id="pause-menu" class="menu-overlay hidden">
            <h1>PAUSED</h1>
            <button class="btn" onclick="game.resume()">RESUME</button>
            <button class="btn" onclick="location.reload()">QUIT TO MENU</button>
        </div>

        <div id="hud" class="hidden">
            <div class="hud-top">
                <div class="stats-group">
                    <div id="points-display" style="color: #4CAF50; font-size: 1.8rem; font-weight: bold;">£ 0</div>
                </div>
                <div id="minimap-container">
                    <canvas id="minimap-canvas"></canvas>
                </div>
            </div>

            <div id="crosshair"></div>
            <div id="interact-prompt" class="hidden">[E] BUY WEAPON UPGRADE</div>

            <div class="hud-bottom">
                <div class="stats-group">
                    <div id="weapon-name" style="letter-spacing: 2px;">L85A2 RIFLE</div>
                    <div id="ammo-display" style="font-size: 1.2rem; opacity: 0.8;">30 / ∞</div>
                </div>
                <div class="stats-group">
                    <div style="font-weight: bold;">CONDITION</div>
                    <div class="bar-container"><div id="health-fill"></div></div>
                </div>
            </div>
        </div>
    </div>

<script>
/**
 * REGION: AUDIO SYSTEM (Synthesized)
 */
class GameAudio {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.master = this.ctx.createGain();
        this.master.connect(this.ctx.destination);
    }

    playShoot() {
        const osc = this.ctx.createOscillator();
        const noise = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        
        const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.1, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
        
        noise.buffer = buffer;
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(1200, this.ctx.currentTime);
        
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(this.master);
        
        gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
        noise.start();
    }

    playZombie() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(60 + Math.random() * 40, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(30, this.ctx.currentTime + 0.5);
        
        osc.connect(gain);
        gain.connect(this.master);
        gain.gain.setValueAtTime(0.05, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);
        
        osc.start();
        osc.stop(this.ctx.currentTime + 0.5);
    }

    playFootstep() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.frequency.setValueAtTime(100, this.ctx.currentTime);
        osc.connect(gain);
        gain.connect(this.master);
        gain.gain.setValueAtTime(0.02, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.1);
    }

    startMusic() {
        const loop = () => {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.frequency.setValueAtTime(40, this.ctx.currentTime);
            osc.connect(gain);
            gain.connect(this.master);
            gain.gain.setValueAtTime(0.02, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 2);
            osc.start();
            osc.stop(this.ctx.currentTime + 2);
            setTimeout(loop, 2000);
        };
        loop();
    }
}
const audio = new GameAudio();

/**
 * REGION: WORLD GENERATION
 */
function createTexture(color, noise = 0.2, stripe = false) {
    const canvas = document.createElement('canvas');
    canvas.width = canvas.height = 256;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = color;
    ctx.fillRect(0,0,256,256);
    
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    for(let i=0; i<2000; i++) ctx.fillRect(Math.random()*256, Math.random()*256, 1, 1);
    
    if(stripe) {
        ctx.fillStyle = 'white';
        ctx.fillRect(120, 0, 16, 100);
        ctx.fillRect(120, 156, 16, 100);
    }
    
    return new THREE.CanvasTexture(canvas);
}

class CityWorld {
    constructor(scene) {
        this.scene = scene;
        this.collidables = [];
        this.shops = [];
        this.init();
    }

    init() {
        // Road with White Dotted Lines
        const roadTex = createTexture('#222', 0.5, true);
        roadTex.wrapT = THREE.RepeatWrapping;
        roadTex.repeat.set(1, 20);
        const road = new THREE.Mesh(new THREE.PlaneGeometry(16, 400), new THREE.MeshStandardMaterial({map: roadTex}));
        road.rotation.x = -Math.PI/2;
        road.receiveShadow = true;
        this.scene.add(road);

        // Pavements
        const pavTex = createTexture('#666');
        [-11, 11].forEach(x => {
            const p = new THREE.Mesh(new THREE.PlaneGeometry(6, 400), new THREE.MeshStandardMaterial({map: pavTex}));
            p.rotation.x = -Math.PI/2;
            p.position.set(x, 0.05, 0);
            p.receiveShadow = true;
            this.scene.add(p);
        });

        // Buildings (Dense blocks)
        const brickTex = createTexture('#5d2906');
        for(let i=0; i<16; i++) {
            const side = (i % 2 === 0) ? 1 : -1;
            this.addBuilding(side * 22, (i - 8) * 25, brickTex);
        }

        // Parked Cars
        const carColors = [0x7b1113, 0x11447b, 0x333333, 0x555555];
        for(let i=0; i<12; i++) {
            const z = (Math.random() - 0.5) * 350;
            const x = Math.random() > 0.5 ? -9 : 9;
            this.addCar(x, z, carColors[Math.floor(Math.random()*carColors.length)]);
        }

        // Gun Crate Shops
        this.addShop(9.5, 30, "M4 CARBINE", 1000);
        this.addShop(-9.5, -60, "SHOTGUN", 2500);
    }

    addBuilding(x, z, tex) {
        const h = 15 + Math.random() * 25;
        const b = new THREE.Mesh(new THREE.BoxGeometry(16, h, 20), new THREE.MeshStandardMaterial({map: tex}));
        b.position.set(x, h/2, z);
        b.castShadow = true;
        b.receiveShadow = true;
        this.scene.add(b);
        this.collidables.push(b);

        // Window Decals
        const winGeo = new THREE.PlaneGeometry(1.5, 2);
        const winMat = new THREE.MeshBasicMaterial({color: 0x000000});
        for(let y=4; y<h-2; y+=5) {
            for(let wz=-7; wz<=7; wz+=4) {
                const w = new THREE.Mesh(winGeo, winMat);
                w.position.set(x > 0 ? -8.01 : 8.01, y, z + wz);
                w.rotation.y = x > 0 ? -Math.PI/2 : Math.PI/2;
                this.scene.add(w);
            }
        }
    }

    addCar(x, z, color) {
        const group = new THREE.Group();
        const body = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.8, 4.5), new THREE.MeshStandardMaterial({color: color}));
        body.position.y = 0.6;
        const roof = new THREE.Mesh(new THREE.BoxGeometry(2, 0.7, 2.5), new THREE.MeshStandardMaterial({color: 0x111111}));
        roof.position.set(0, 1.3, -0.2);
        group.add(body, roof);
        
        // Wheels
        const wheelGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.4);
        const wheelMat = new THREE.MeshStandardMaterial({color: 0x000000});
        [[-1.1, 0.35, 1.5], [1.1, 0.35, 1.5], [-1.1, 0.35, -1.5], [1.1, 0.35, -1.5]].forEach(p => {
            const w = new THREE.Mesh(wheelGeo, wheelMat);
            w.rotation.z = Math.PI/2;
            w.position.set(...p);
            group.add(w);
        });

        group.position.set(x, 0, z);
        group.rotation.y = (Math.random() - 0.5) * 0.2;
        this.scene.add(group);
        this.collidables.push(body);
    }

    addShop(x, z, item, price) {
        const crate = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.8, 1.2), new THREE.MeshStandardMaterial({color: 0x5d4037}));
        crate.position.set(x, 0.4, z);
        this.scene.add(crate);
        this.shops.push({ pos: new THREE.Vector3(x, 0, z), item, price });
    }
}

/**
 * REGION: ENTITIES (PLAYER & ZOMBIE)
 */
class Zombie {
    constructor(scene, player, pos) {
        this.scene = scene;
        this.player = player;
        this.health = 100;
        this.dead = false;
        this.group = new THREE.Group();
        
        const mat = new THREE.MeshStandardMaterial({color: 0x4a5d23});
        const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), mat);
        head.position.y = 1.7;
        const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.9, 0.3), new THREE.MeshStandardMaterial({color: 0x223322}));
        body.position.y = 1.05;
        
        this.armL = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.7, 0.15), mat);
        this.armL.position.set(-0.4, 1.2, 0.2);
        this.armL.rotation.x = -Math.PI/2.2;
        this.armR = this.armL.clone(); this.armR.position.x = 0.4;
        
        const leg = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.7, 0.2), new THREE.MeshStandardMaterial({color: 0x111111}));
        leg.position.set(-0.2, 0.35, 0);
        const legR = leg.clone(); legR.position.x = 0.2;

        this.group.add(head, body, this.armL, this.armR, leg, legR);
        this.group.position.copy(pos);
        this.scene.add(this.group);
    }

    update(delta) {
        if(this.dead) return;
        const d = this.group.position.distanceTo(this.player.camera.position);
        if(d < 30) {
            this.group.lookAt(this.player.camera.position.x, 0, this.player.camera.position.z);
            const move = new THREE.Vector3(0,0,1).applyQuaternion(this.group.quaternion).multiplyScalar(0.05 * delta);
            this.group.position.add(move);
            
            // Animation
            this.armL.rotation.x = -Math.PI/2 + Math.sin(Date.now() * 0.01) * 0.3;
            
            if(d < 1.6 && Math.random() < 0.03) {
                this.player.damage(5);
                if(Math.random() < 0.1) audio.playZombie();
            }
        }
    }

    hit(dmg) {
        this.health -= dmg;
        if(this.health <= 0) {
            this.dead = true;
            this.scene.remove(this.group);
            return true;
        }
        return false;
    }
}

class Player {
    constructor(scene, camera) {
        this.scene = scene;
        this.camera = camera;
        this.health = 100;
        this.points = 0;
        this.velocity = new THREE.Vector3();
        this.move = { f:0, b:0, l:0, r:0, shift: false };
        this.yaw = new THREE.Object3D();
        this.pitch = new THREE.Object3D();
        this.yaw.add(this.pitch);
        this.pitch.add(camera);
        this.yaw.position.set(0, 1.8, 5);
        scene.add(this.yaw);

        this.gun = this.createGun();
        this.pitch.add(this.gun);
        
        this.setupInput();
    }

    createGun() {
        const group = new THREE.Group();
        const body = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.18, 0.8), new THREE.MeshStandardMaterial({color: 0x111111}));
        const grip = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.25, 0.1), new THREE.MeshStandardMaterial({color: 0x050505}));
        grip.position.set(0, -0.2, 0.2);
        const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.4), new THREE.MeshStandardMaterial({color: 0x000000}));
        barrel.rotation.x = Math.PI/2; barrel.position.z = -0.5;
        group.add(body, grip, barrel);
        group.position.set(0.4, -0.3, -0.5);
        return group;
    }

    setupInput() {
        document.addEventListener('keydown', e => {
            if(e.code==='KeyW') this.move.f=1; if(e.code==='KeyS') this.move.b=1;
            if(e.code==='KeyA') this.move.l=1; if(e.code==='KeyD') this.move.r=1;
            if(e.code==='ShiftLeft') this.move.shift=true;
            if(e.code==='KeyE') this.interact();
            if(e.code==='Space' && Math.abs(this.velocity.y) < 0.01) this.velocity.y = 0.16;
        });
        document.addEventListener('keyup', e => {
            if(e.code==='KeyW') this.move.f=0; if(e.code==='KeyS') this.move.b=0;
            if(e.code==='KeyA') this.move.l=0; if(e.code==='KeyD') this.move.r=0;
            if(e.code==='ShiftLeft') this.move.shift=false;
        });
        document.addEventListener('mousemove', e => {
            if(document.pointerLockElement) {
                this.yaw.rotation.y -= e.movementX * 0.002;
                this.pitch.rotation.x -= e.movementY * 0.002;
                this.pitch.rotation.x = Math.max(-1.5, Math.min(1.5, this.pitch.rotation.x));
            }
        });
        document.addEventListener('mousedown', () => { if(document.pointerLockElement) this.shoot(); });
    }

    shoot() {
        audio.playShoot();
        this.gun.position.z += 0.15;
        const ray = new THREE.Raycaster();
        ray.setFromCamera(new THREE.Vector2(0,0), this.camera);
        const hits = ray.intersectObjects(game.zombies.map(z => z.group), true);
        if(hits.length > 0) {
            let obj = hits[0].object;
            while(obj.parent && !obj.userData.isZombie) {
                if(obj.parent.type === 'Group') break;
                obj = obj.parent;
            }
            const z = game.zombies.find(z => z.group.uuid === hits[0].object.parent.uuid || z.group.uuid === hits[0].object.uuid);
            if(z && z.hit(40)) this.points += 150;
        }
    }

    damage(amt) {
        this.health -= amt;
        document.getElementById('damage-flash').style.opacity = 1;
        setTimeout(() => document.getElementById('damage-flash').style.opacity = 0, 100);
        if(this.health <= 0) game.over();
    }

    interact() {
        game.world.shops.forEach(s => {
            if(this.yaw.position.distanceTo(s.pos) < 3.5 && this.points >= s.price) {
                this.points -= s.price;
                document.getElementById('weapon-name').innerText = s.item;
                audio.playFootstep();
            }
        });
    }

    update(delta) {
        const s = (this.move.shift ? 0.22 : 0.12) * delta;
        const dir = new THREE.Vector3(this.move.r - this.move.l, 0, this.move.b - this.move.f).normalize();
        this.velocity.x = dir.x * s;
        this.velocity.z = dir.z * s;
        this.velocity.y -= 0.009 * delta;

        this.yaw.translateX(this.velocity.x);
        this.yaw.translateZ(this.velocity.z);
        this.yaw.position.y += this.velocity.y;

        if(this.yaw.position.y < 1.8) {
            this.yaw.position.y = 1.8;
            this.velocity.y = 0;
            if(Math.abs(this.velocity.x) + Math.abs(this.velocity.z) > 0.05 && Math.random() < 0.1) audio.playFootstep();
        }

        this.gun.position.z += (-0.5 - this.gun.position.z) * 0.15;
        this.camera.position.y = Math.sin(Date.now() * 0.01) * 0.05; // Head bob

        document.getElementById('health-fill').style.width = this.health + '%';
        document.getElementById('points-display').innerText = '£ ' + this.points;
    }
}

/**
 * REGION: CORE GAME ENGINE
 */
class GameEngine {
    constructor() {
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x8899aa);
        this.scene.fog = new THREE.Fog(0x8899aa, 10, 140);

        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({antialias: true});
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.shadowMap.enabled = true;
        document.body.appendChild(this.renderer.domElement);

        const sun = new THREE.DirectionalLight(0xffffff, 1);
        sun.position.set(40, 60, 20);
        sun.castShadow = true;
        this.scene.add(sun, new THREE.AmbientLight(0xffffff, 0.5));

        this.world = new CityWorld(this.scene);
        this.player = new Player(this.scene, this.camera);
        this.zombies = [];
        this.paused = true;
        this.clock = new THREE.Clock();

        this.miniCanvas = document.getElementById('minimap-canvas');
        this.miniCtx = this.miniCanvas.getContext('2d');
        
        this.loop();
    }

    start() {
        this.paused = false;
        document.body.requestPointerLock();
        document.getElementById('main-menu').classList.add('hidden');
        document.getElementById('hud').classList.remove('hidden');
        audio.ctx.resume();
        audio.startMusic();
        this.spawn(15);
    }

    resume() {
        this.paused = false;
        document.body.requestPointerLock();
        document.getElementById('pause-menu').classList.add('hidden');
    }

    spawn(n) {
        for(let i=0; i<n; i++) {
            const pos = new THREE.Vector3((Math.random()-0.5)*30, 0, (Math.random()-0.5)*300);
            if(pos.distanceTo(this.player.yaw.position) > 15) {
                this.zombies.push(new Zombie(this.scene, this.player, pos));
            }
        }
    }

    drawMinimap() {
        const ctx = this.miniCtx;
        ctx.clearRect(0,0,200,200);
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(0,0,200,200);
        
        const px = this.player.yaw.position.x;
        const pz = this.player.yaw.position.z;

        // Shops
        ctx.fillStyle = '#ffeb3b';
        this.world.shops.forEach(s => {
            const mx = 100 + (s.pos.x - px) * 2;
            const mz = 100 + (s.pos.z - pz) * 2;
            ctx.fillRect(mx-4, mz-4, 8, 8);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 10px Arial';
            ctx.fillText("SHOP", mx+6, mz+4);
            ctx.fillStyle = '#ffeb3b';
        });

        // Player
        ctx.fillStyle = '#00ff00';
        ctx.beginPath(); ctx.arc(100, 100, 4, 0, Math.PI*2); ctx.fill();
    }

    over() {
        this.paused = true;
        document.exitPointerLock();
        alert("YOU PERISHED IN THE STREETS. Score: " + this.player.points);
        location.reload();
    }

    loop() {
        requestAnimationFrame(() => this.loop());
        if(!this.paused) {
            const delta = this.clock.getDelta() * 60;
            this.player.update(delta);
            this.zombies.forEach(z => z.update(delta));
            this.zombies = this.zombies.filter(z => !z.dead);
            if(this.zombies.length < 12) this.spawn(5);
            
            this.drawMinimap();
            
            let near = false;
            this.world.shops.forEach(s => {
                if(this.player.yaw.position.distanceTo(s.pos) < 3.5) near = true;
            });
            document.getElementById('interact-prompt').classList.toggle('hidden', !near);
        }
        this.renderer.render(this.scene, this.camera);
    }
}

document.addEventListener('pointerlockchange', () => {
    if(!document.pointerLockElement && !game.paused) {
        game.paused = true;
        document.getElementById('pause-menu').classList.remove('hidden');
    }
});

const game = new GameEngine();

window.addEventListener('resize', () => {
    game.camera.aspect = window.innerWidth / window.innerHeight;
    game.camera.updateProjectionMatrix();
    game.renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
