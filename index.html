<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LONDON EXTINCTION | ULTIMATE SURVIVAL</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* CSS REGION: STYLING THE APOCALYPSE */
        :root { 
            --london-red: #8b0000; 
            --ui-gold: #ffd700; 
            --hud-bg: rgba(0, 0, 0, 0.85); 
            --accent: #ff3300;
        }

        body, html { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            overflow: hidden; background: #000; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #eeeeee;
        }

        canvas { display: block; }

        /* MENU SYSTEM */
        #ui-overlay { 
            position: absolute; inset: 0; pointer-events: none; z-index: 1000; 
        }

        .screen {
            position: absolute; inset: 0; display: flex; flex-direction: column;
            align-items: center; justify-content: center; background: #000;
            pointer-events: all; transition: opacity 0.8s ease;
        }

        .hidden { display: none !important; opacity: 0; }

        h1 { 
            font-size: 5rem; letter-spacing: 20px; color: var(--london-red);
            text-shadow: 0 0 30px rgba(139, 0, 0, 0.8); margin: 0;
            text-transform: uppercase; font-weight: 900;
        }

        .subtitle { font-size: 1.2rem; letter-spacing: 5px; margin-bottom: 3rem; color: #555; }

        .menu-btn {
            background: transparent; border: 1px solid #333; color: #fff;
            padding: 20px 80px; font-size: 1.1rem; cursor: pointer;
            margin: 10px; width: 400px; text-transform: uppercase;
            transition: all 0.3s; position: relative; overflow: hidden;
        }

        .menu-btn:hover {
            background: #fff; color: #000; border-color: #fff;
            box-shadow: 0 0 40px rgba(255, 255, 255, 0.2);
            transform: translateY(-3px);
        }

        /* HUD ELEMENTS */
        #hud {
            position: absolute; inset: 0; display: flex; flex-direction: column;
            justify-content: space-between; padding: 40px; pointer-events: none;
        }

        .hud-top { display: flex; justify-content: space-between; align-items: flex-start; }
        .hud-bottom { display: flex; justify-content: space-between; align-items: flex-end; }

        .panel {
            background: var(--hud-bg); padding: 25px;
            border-bottom: 4px solid var(--london-red);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        #minimap-wrapper {
            width: 240px; height: 240px; background: #050505;
            border: 2px solid #222; position: relative;
        }

        #minimap-canvas { width: 100%; height: 100%; }

        .stat-label { font-size: 0.7rem; color: #888; text-transform: uppercase; margin-bottom: 5px; }
        .stat-value { font-size: 2rem; font-weight: bold; letter-spacing: 2px; }

        #health-container { width: 300px; height: 8px; background: #111; margin-top: 10px; border: 1px solid #333; }
        #health-bar { height: 100%; width: 100%; background: var(--accent); transition: width 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28); }

        #crosshair {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 30px; height: 30px; pointer-events: none;
        }

        .ch-part { position: absolute; background: rgba(255,255,255,0.7); }
        .ch-h { width: 10px; height: 2px; top: 14px; }
        .ch-v { width: 2px; height: 10px; left: 14px; }

        #interact-hint {
            position: absolute; bottom: 35%; left: 50%; transform: translateX(-50%);
            color: var(--ui-gold); font-weight: bold; font-size: 1.4rem;
            text-shadow: 0 0 10px #000;
        }

        #damage-vignette {
            position: absolute; inset: 0; pointer-events: none;
            box-shadow: inset 0 0 0px rgba(255,0,0,0);
            transition: box-shadow 0.1s;
        }
    </style>
</head>
<body>

    <div id="ui-overlay">
        <div id="damage-vignette"></div>

        <div id="screen-start" class="screen">
            <h1>LONDON</h1>
            <div class="subtitle">PROJECT EXTINCTION 2026</div>
            <button class="menu-btn" onclick="gameEngine.start()">Begin Clearing</button>
            <button class="menu-btn" onclick="alert('WASD - Move\nSHIFT - Sprint\nSPACE - Jump\nE - Purchase\nLMB - Shoot')">Protocol</button>
        </div>

        <div id="screen-pause" class="screen hidden">
            <h1>PAUSED</h1>
            <button class="menu-btn" onclick="gameEngine.resume()">Resume Mission</button>
            <button class="menu-btn" onclick="location.reload()">Abort</button>
        </div>

        <div id="hud" class="hidden">
            <div class="hud-top">
                <div class="panel" style="border-bottom-color: #44ff44;">
                    <div class="stat-label">Currency Collected</div>
                    <div id="pts-val" class="stat-value" style="color: #44ff44;">£ 0</div>
                </div>
                <div id="minimap-wrapper">
                    <canvas id="minimap-canvas"></canvas>
                </div>
            </div>

            <div id="crosshair">
                <div class="ch-part ch-h" style="left: 0;"></div>
                <div class="ch-part ch-h" style="right: 0;"></div>
                <div class="ch-part ch-v" style="top: 0;"></div>
                <div class="ch-part ch-v" style="bottom: 0;"></div>
            </div>

            <div id="interact-hint" class="hidden">[E] UPGRADE ARMAMENT</div>

            <div class="hud-bottom">
                <div class="panel">
                    <div id="gun-name" class="stat-label" style="color: #fff; font-size: 1rem;">L85A2 SERVICE RIFLE</div>
                    <div class="stat-label">Tactical Status: Optimized</div>
                </div>
                <div class="panel">
                    <div class="stat-label">Physical Integrity</div>
                    <div id="hp-text" class="stat-value">100%</div>
                    <div id="health-container"><div id="health-bar"></div></div>
                </div>
            </div>
        </div>
    </div>

<script>
/** * ============================================================================
 * URBAN EXTINCTION - CORE ENGINE v2.0
 * ============================================================================
 */

/**
 * AUDIO ARCHITECT
 * High-performance synthesized soundscapes
 */
class AudioManager {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.master = this.ctx.createGain();
        this.master.connect(this.ctx.destination);
    }

    // Advanced shooting sound with tail and mechanical click
    playShot() {
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        osc.type = 'square';
        osc.frequency.setValueAtTime(150, t);
        osc.frequency.exponentialRampToValueAtTime(40, t + 0.1);
        g.gain.setValueAtTime(0.3, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
        osc.connect(g); g.connect(this.master);
        osc.start(); osc.stop(t + 0.3);

        const noise = this.ctx.createBufferSource();
        const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.1, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
        noise.buffer = buffer;
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass'; filter.frequency.value = 1000;
        const ng = this.ctx.createGain();
        ng.gain.setValueAtTime(0.2, t);
        ng.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
        noise.connect(filter); filter.connect(ng); ng.connect(this.master);
        noise.start();
    }

    playStep() {
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        osc.frequency.setValueAtTime(60, t);
        g.gain.setValueAtTime(0.03, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
        osc.connect(g); g.connect(this.master);
        osc.start(); osc.stop(t + 0.1);
    }

    playMoan() {
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(80 + Math.random() * 40, t);
        osc.frequency.linearRampToValueAtTime(30, t + 1.2);
        g.gain.setValueAtTime(0.02, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 1.2);
        osc.connect(g); g.connect(this.master);
        osc.start(); osc.stop(t + 1.2);
    }

    playBuy() {
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        osc.frequency.setValueAtTime(440, t);
        osc.frequency.exponentialRampToValueAtTime(880, t + 0.1);
        g.gain.setValueAtTime(0.1, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
        osc.connect(g); g.connect(this.master);
        osc.start(); osc.stop(t + 0.2);
    }
}
const audio = new AudioManager();

/**
 * TEXTURE FACTORY
 * Procedural generation for high-performance city visuals
 */
const TextureFactory = {
    asphalt: () => {
        const c = document.createElement('canvas');
        c.width = c.height = 512;
        const x = c.getContext('2d');
        x.fillStyle = '#1a1a1a'; x.fillRect(0,0,512,512);
        for(let i=0; i<10000; i++) {
            x.fillStyle = `rgba(255,255,255,${Math.random()*0.05})`;
            x.fillRect(Math.random()*512, Math.random()*512, 2, 2);
        }
        // Road Markings
        x.fillStyle = '#fff';
        x.fillRect(250, 0, 12, 120); x.fillRect(250, 200, 12, 120); x.fillRect(250, 400, 12, 120);
        return new THREE.CanvasTexture(c);
    },
    brick: () => {
        const c = document.createElement('canvas');
        c.width = c.height = 256;
        const x = c.getContext('2d');
        x.fillStyle = '#4a2511'; x.fillRect(0,0,256,256);
        x.strokeStyle = '#221100'; x.lineWidth = 2;
        for(let y=0; y<256; y+=16) {
            x.beginPath(); x.moveTo(0,y); x.lineTo(256,y); x.stroke();
            for(let sx=(y%32===0?0:16); sx<256; sx+=32) {
                x.beginPath(); x.moveTo(sx,y); x.lineTo(sx,y+16); x.stroke();
            }
        }
        return new THREE.CanvasTexture(c);
    },
    zombieSkin: () => {
        const c = document.createElement('canvas');
        c.width = c.height = 128;
        const x = c.getContext('2d');
        x.fillStyle = '#3a4d23'; x.fillRect(0,0,128,128);
        x.fillStyle = '#220000';
        for(let i=0; i<50; i++) x.fillRect(Math.random()*128, Math.random()*128, 4, 4);
        // Face features
        x.fillStyle = 'white'; x.fillRect(30, 40, 15, 8); x.fillRect(80, 40, 15, 8); // Eyes
        x.fillStyle = 'red'; x.fillRect(35, 42, 4, 4); x.fillRect(85, 42, 4, 4); // Pupils
        x.fillStyle = '#000'; x.fillRect(40, 85, 48, 15); // Mouth
        return new THREE.CanvasTexture(c);
    }
};

/**
 * CITY ARCHITECT
 * Manages geometry and environment
 */
class WorldManager {
    constructor(scene) {
        this.scene = scene;
        this.collidables = [];
        this.shops = [];
        this.init();
    }

    init() {
        // Floor & Atmosphere
        const roadTex = TextureFactory.asphalt();
        roadTex.wrapS = roadTex.wrapT = THREE.RepeatWrapping;
        roadTex.repeat.set(1, 40);
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(24, 1000),
            new THREE.MeshStandardMaterial({map: roadTex, roughness: 0.9})
        );
        ground.rotation.x = -Math.PI/2;
        ground.receiveShadow = true;
        this.scene.add(ground);

        // Green Belt & Background
        const grass = new THREE.Mesh(
            new THREE.PlaneGeometry(2000, 2000),
            new THREE.MeshStandardMaterial({color: 0x0a1a0a})
        );
        grass.rotation.x = -Math.PI/2;
        grass.position.y = -0.2;
        this.scene.add(grass);

        // Perimeter Fencing
        this.createFenceLine(12, 500);
        this.createFenceLine(-12, 500);

        // Generative Streets
        const brickTex = TextureFactory.brick();
        for(let i=0; i<30; i++) {
            const side = i % 2 === 0 ? 1 : -1;
            this.createBuilding(side * 35, (i - 15) * 60, brickTex);
        }

        // Prop Generation: Cars
        for(let i=0; i<20; i++) {
            const lane = Math.random() > 0.5 ? 6 : -6;
            this.createCar(lane, (Math.random() - 0.5) * 800);
        }

        // Armory Shops
        this.createShop(9, 30, "M4A1 CARBINE", 1500, 1);
        this.createShop(-9, -120, "H&K MG4", 5000, 2);
    }

    createFenceLine(x, length) {
        const geo = new THREE.BoxGeometry(0.5, 4, length);
        const mat = new THREE.MeshStandardMaterial({color: 0x222222, wireframe: true});
        const fence = new THREE.Mesh(geo, mat);
        fence.position.set(x, 2, 0);
        this.scene.add(fence);
    }

    createBuilding(x, z, tex) {
        const height = 20 + Math.random() * 40;
        const geo = new THREE.BoxGeometry(30, height, 40);
        const mat = new THREE.MeshStandardMaterial({map: tex, color: 0x888888});
        const building = new THREE.Mesh(geo, mat);
        building.position.set(x, height/2, z);
        this.scene.add(building);
        this.collidables.push(building);

        // Window Integration (Embedded, not floating)
        const winGeo = new THREE.BoxGeometry(0.2, 3, 2);
        const winMat = new THREE.MeshStandardMaterial({color: 0x000000, emissive: 0x111111});
        for(let y=5; y<height-5; y+=8) {
            for(let wz=-15; wz<=15; wz+=10) {
                const w = new THREE.Mesh(winGeo, winMat);
                w.position.set(x > 0 ? -15 : 15, y, z + wz);
                this.scene.add(w);
            }
        }
    }

    createCar(x, z) {
        const colors = [0x550000, 0x000055, 0x222222, 0x444444];
        const group = new THREE.Group();
        const body = new THREE.Mesh(new THREE.BoxGeometry(2.5, 1, 5), new THREE.MeshStandardMaterial({color: colors[Math.floor(Math.random()*4)]}));
        body.position.y = 0.6;
        const top = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.8, 2.5), new THREE.MeshStandardMaterial({color: 0x0a0a0a}));
        top.position.set(0, 1.4, -0.2);
        group.add(body, top);
        group.position.set(x, 0, z);
        group.rotation.y = Math.random() * 0.4 - 0.2;
        this.scene.add(group);
        this.collidables.push(body);
    }

    createShop(x, z, name, price, tier) {
        const group = new THREE.Group();
        const base = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), new THREE.MeshStandardMaterial({color: 0x332211}));
        const light = new THREE.PointLight(0xffff00, 1, 5);
        light.position.y = 2;
        group.add(base, light);
        group.position.set(x, 1, z);
        this.scene.add(group);
        this.shops.push({ pos: new THREE.Vector3(x, 1, z), name, price, tier });
    }
}

/**
 * ENTITY CLASS: ZOMBIE
 */
class Zombie {
    constructor(scene, player, pos) {
        this.scene = scene;
        this.player = player;
        this.hp = 100;
        this.dead = false;
        this.mesh = this.createMesh();
        this.mesh.position.copy(pos);
        this.scene.add(this.mesh);
        this.velocity = new THREE.Vector3();
    }

    createMesh() {
        const g = new THREE.Group();
        const skinMat = new THREE.MeshStandardMaterial({map: TextureFactory.zombieSkin()});
        const clothMat = new THREE.MeshStandardMaterial({color: 0x222222});

        const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), skinMat);
        head.position.y = 1.9;
        const torso = new THREE.Mesh(new THREE.BoxGeometry(0.7, 1.1, 0.4), clothMat);
        torso.position.y = 1.1;
        
        this.armL = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.8, 0.2), skinMat);
        this.armL.position.set(-0.45, 1.3, 0.3);
        this.armL.rotation.x = -Math.PI/2.5;

        this.armR = this.armL.clone(); this.armR.position.x = 0.45;

        const legL = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.9, 0.25), clothMat);
        legL.position.set(-0.2, 0.45, 0);
        const legR = legL.clone(); legR.position.x = 0.2;

        g.add(head, torso, this.armL, this.armR, legL, legR);
        return g;
    }

    update(delta) {
        if(this.dead) return;
        const dist = this.mesh.position.distanceTo(this.player.yaw.position);
        
        if(dist < 60) {
            this.mesh.lookAt(this.player.yaw.position.x, 0, this.player.yaw.position.z);
            const speed = 0.065 * delta;
            this.mesh.translateZ(speed);

            // Shambling animation
            this.armL.rotation.x = -Math.PI/2 + Math.sin(Date.now()*0.01)*0.3;
            this.armR.rotation.x = -Math.PI/2 + Math.cos(Date.now()*0.01)*0.3;
            this.mesh.position.y = Math.abs(Math.sin(Date.now()*0.005)) * 0.15;

            if(Math.random() < 0.005) audio.playMoan();

            if(dist < 2) {
                this.player.takeDamage(0.6 * delta);
            }
        }
    }

    damage(val) {
        this.hp -= val;
        if(this.hp <= 0) {
            this.dead = true;
            this.scene.remove(this.mesh);
            return true;
        }
        return false;
    }
}

/**
 * ENTITY CLASS: PLAYER
 */
class PlayerController {
    constructor(scene, camera) {
        this.scene = scene;
        this.camera = camera;
        this.hp = 100;
        this.pts = 0;
        this.tier = 0;
        
        this.yaw = new THREE.Object3D();
        this.pitch = new THREE.Object3D();
        this.yaw.add(this.pitch);
        this.pitch.add(camera);
        this.yaw.position.set(0, 2, 5);
        this.scene.add(this.yaw);

        this.vel = new THREE.Vector3();
        this.input = {f:0, b:0, l:0, r:0, run:false};
        this.lastShot = 0;

        this.weapon = this.buildWeapon();
        this.pitch.add(this.weapon);

        this.initControls();
    }

    buildWeapon() {
        const group = new THREE.Group();
        const mat = new THREE.MeshStandardMaterial({color: 0x111111, metalness: 0.8});
        const body = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.2, 1), mat);
        const grip = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.3, 0.15), mat);
        grip.position.set(0, -0.2, 0.3);
        const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.6), mat);
        barrel.rotation.x = Math.PI/2; barrel.position.z = -0.6;
        
        group.add(body, grip, barrel);
        group.position.set(0.4, -0.4, -0.7);
        return group;
    }

    initControls() {
        document.onkeydown = (e) => {
            const k = e.code;
            if(k==='KeyW') this.input.f=1; if(k==='KeyS') this.input.b=1;
            if(k==='KeyA') this.input.l=1; if(k==='KeyD') this.input.r=1;
            if(k==='ShiftLeft') this.input.run=true;
            if(k==='KeyE') this.interact();
            if(k==='Space' && Math.abs(this.vel.y) < 0.01) this.vel.y = 0.18;
        };
        document.onkeyup = (e) => {
            const k = e.code;
            if(k==='KeyW') this.input.f=0; if(k==='KeyS') this.input.b=0;
            if(k==='KeyA') this.input.l=0; if(k==='KeyD') this.input.r=0;
            if(k==='ShiftLeft') this.input.run=false;
        };
        document.onmousemove = (e) => {
            if(document.pointerLockElement) {
                this.yaw.rotation.y -= e.movementX * 0.002;
                this.pitch.rotation.x -= e.movementY * 0.002;
                this.pitch.rotation.x = Math.max(-1.5, Math.min(1.5, this.pitch.rotation.x));
            }
        };
        document.onmousedown = () => { if(document.pointerLockElement) this.fire(); };
    }

    fire() {
        const now = Date.now();
        const cooldown = this.tier === 0 ? 350 : (this.tier === 1 ? 140 : 70);
        if(now - this.lastShot < cooldown) return;
        this.lastShot = now;

        audio.playShot();
        this.weapon.position.z += 0.15; // Recoil

        const ray = new THREE.Raycaster();
        ray.setFromCamera(new THREE.Vector2(0,0), this.camera);
        const targets = gameEngine.zombies.map(z => z.mesh);
        const hits = ray.intersectObjects(targets, true);

        if(hits.length > 0) {
            let hitObj = hits[0].object;
            while(hitObj.parent && !hitObj.parent.type === 'Scene') hitObj = hitObj.parent;
            const z = gameEngine.zombies.find(z => z.mesh.uuid === hitObj.uuid || z.mesh.uuid === hits[0].object.parent.uuid);
            if(z && z.damage(this.tier === 0 ? 34 : 50)) {
                this.pts += 150;
            }
        }
    }

    takeDamage(amt) {
        this.hp -= amt;
        const vignette = document.getElementById('damage-vignette');
        vignette.style.boxShadow = 'inset 0 0 100px rgba(255,0,0,0.8)';
        setTimeout(() => vignette.style.boxShadow = 'inset 0 0 0px rgba(255,0,0,0)', 100);
        if(this.hp <= 0) location.reload();
    }

    interact() {
        gameEngine.world.shops.forEach(s => {
            if(this.yaw.position.distanceTo(s.pos) < 5 && this.pts >= s.price) {
                this.pts -= s.price;
                this.tier = s.tier;
                document.getElementById('gun-name').innerText = s.name;
                audio.playBuy();
                this.weapon.children.forEach(c => c.material.color.setHex(this.tier === 1 ? 0x444466 : 0x664444));
            }
        });
    }

    update(delta) {
        // Movement Logic
        const speed = (this.input.run ? 0.28 : 0.14) * delta;
        const moveDir = new THREE.Vector3(this.input.r - this.input.l, 0, this.input.b - this.input.f).normalize();
        this.vel.x = moveDir.x * speed;
        this.vel.z = moveDir.z * speed;
        this.vel.y -= 0.009 * delta; // Gravity

        this.yaw.translateX(this.vel.x);
        this.yaw.translateZ(this.vel.z);
        this.yaw.position.y += this.vel.y;

        // Ground & Bobbing
        if(this.yaw.position.y < 2) {
            this.yaw.position.y = 2;
            this.vel.y = 0;
            
            const isMoving = Math.abs(this.vel.x) > 0.01 || Math.abs(this.vel.z) > 0.01;
            if(isMoving) {
                const bob = Math.sin(Date.now() * 0.01) * 0.06;
                this.pitch.position.y = bob;
                if(Math.sin(Date.now() * 0.01) > 0.98) audio.playStep();
            } else {
                this.pitch.position.y = THREE.MathUtils.lerp(this.pitch.position.y, 0, 0.1);
            }
        }

        // Recoil Recovery
        this.weapon.position.z = THREE.MathUtils.lerp(this.weapon.position.z, -0.7, 0.2);

        // UI Updates
        document.getElementById('hp-bar').style.width = this.hp + '%';
        document.getElementById('hp-text').innerText = Math.floor(this.hp) + '%';
        document.getElementById('pts-val').innerText = '£ ' + this.pts;
    }
}

/**
 * MAIN ENGINE CLASS
 * Orchestrates the game loop and state
 */
class GameEngine {
    constructor() {
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x8899aa);
        this.scene.fog = new THREE.Fog(0x8899aa, 30, 250);

        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1500);
        this.renderer = new THREE.WebGLRenderer({antialias: true});
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.shadowMap.enabled = true;
        document.body.appendChild(this.renderer.domElement);

        // Lighting
        const sun = new THREE.DirectionalLight(0xffffff, 1.2);
        sun.position.set(100, 200, 100);
        sun.castShadow = true;
        this.scene.add(sun, new THREE.AmbientLight(0xffffff, 0.4));

        this.world = new WorldManager(this.scene);
        this.player = new PlayerController(this.scene, this.camera);
        this.zombies = [];
        this.clock = new THREE.Clock();
        this.paused = true;

        this.mapCtx = document.getElementById('minimap-canvas').getContext('2d');
        document.getElementById('minimap-canvas').width = 240;
        document.getElementById('minimap-canvas').height = 240;

        this.loop();
    }

    start() {
        this.paused = false;
        document.body.requestPointerLock();
        document.getElementById('screen-start').classList.add('hidden');
        document.getElementById('hud').classList.remove('hidden');
        audio.ctx.resume();
        this.spawnWave(25);
    }

    resume() {
        this.paused = false;
        document.body.requestPointerLock();
        document.getElementById('screen-pause').classList.add('hidden');
    }

    spawnWave(n) {
        for(let i=0; i<n; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = 60 + Math.random() * 40;
            const pos = new THREE.Vector3(
                this.player.yaw.position.x + Math.cos(angle) * dist,
                0,
                this.player.yaw.position.z + Math.sin(angle) * dist
            );
            this.zombies.push(new Zombie(this.scene, this.player, pos));
        }
    }

    updateMinimap() {
        const ctx = this.mapCtx;
        ctx.fillStyle = '#050505'; ctx.fillRect(0,0,240,240);
        const px = this.player.yaw.position.x;
        const pz = this.player.yaw.position.z;

        // Draw Shops
        ctx.fillStyle = '#ffff00';
        this.world.shops.forEach(s => {
            const mx = 120 + (s.pos.x - px) * 2;
            const mz = 120 + (s.pos.z - pz) * 2;
            ctx.fillRect(mx-4, mz-4, 8, 8);
        });

        // Draw Zombies
        ctx.fillStyle = '#ff0000';
        this.zombies.forEach(z => {
            const mx = 120 + (z.mesh.position.x - px) * 2;
            const mz = 120 + (z.mesh.position.z - pz) * 2;
            ctx.beginPath(); ctx.arc(mx, mz, 2, 0, Math.PI*2); ctx.fill();
        });

        // Draw Player
        ctx.fillStyle = '#00ff00';
        ctx.beginPath(); ctx.arc(120, 120, 4, 0, Math.PI*2); ctx.fill();
    }

    loop() {
        requestAnimationFrame(() => this.loop());
        if(!this.paused) {
            const delta = this.clock.getDelta() * 60;
            this.player.update(delta);
            this.zombies.forEach(z => z.update(delta));
            this.zombies = this.zombies.filter(z => !z.dead);

            if(this.zombies.length < 15) this.spawnWave(10);
            this.updateMinimap();

            let nearShop = false;
            this.world.shops.forEach(s => {
                if(this.player.yaw.position.distanceTo(s.pos) < 5) nearShop = true;
            });
            document.getElementById('interact-hint').classList.toggle('hidden', !nearShop);
        }
        this.renderer.render(this.scene, this.camera);
    }
}

// Global Init
const gameEngine = new GameEngine();

document.addEventListener('pointerlockchange', () => {
    if(!document.pointerLockElement && !gameEngine.paused) {
        gameEngine.paused = true;
        document.getElementById('screen-pause').classList.remove('hidden');
    }
});

window.addEventListener('resize', () => {
    gameEngine.camera.aspect = window.innerWidth / window.innerHeight;
    gameEngine.camera.updateProjectionMatrix();
    gameEngine.renderer.setSize(window.innerWidth, window.innerHeight);
});

</script>
</body>
</html>
